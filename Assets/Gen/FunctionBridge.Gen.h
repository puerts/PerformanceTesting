

// Auto Gen

#if !__SNC__
#ifndef __has_feature 
#define __has_feature(x) 0 
#endif
#endif

#if _MSC_VER
typedef wchar_t Il2CppChar;
#elif __has_feature(cxx_unicode_literals)
typedef char16_t Il2CppChar;
#else
typedef uint16_t Il2CppChar;
#endif

// Vector3
struct s_r4r4r4_
{
    float p0;
    float p1;
    float p2;
};
    
// Bounds
struct s_r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
};
    
// DateTime
struct s_u8_
{
    uint64_t p0;
};
    
// Color
struct s_r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
};
    
// StreamingContext
struct s_Oi4_
{
    void* p0;
    int32_t p1;
};
    
// NativeArray`1
struct s_Pvi4i4i4pi4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
};
    
// PlaybackState
struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_
{
    float p0;
    float p1;
    float p2;
    int32_t p3;
    float p4;
    float p5;
    uint32_t p6;
    uint32_t p7;
    uint32_t p8;
    uint32_t p9;
    uint32_t p10;
    uint32_t p11;
    uint32_t p12;
    uint32_t p13;
    uint32_t p14;
    uint32_t p15;
    uint32_t p16;
    uint32_t p17;
    uint32_t p18;
    uint32_t p19;
    uint32_t p20;
    uint32_t p21;
    uint32_t p22;
    uint32_t p23;
    uint32_t p24;
    uint32_t p25;
    uint32_t p26;
    uint32_t p27;
    uint32_t p28;
    uint32_t p29;
    uint32_t p30;
    uint32_t p31;
    uint32_t p32;
    uint32_t p33;
    uint32_t p34;
    uint32_t p35;
    uint32_t p36;
    uint32_t p37;
    uint32_t p38;
    uint32_t p39;
    uint32_t p40;
    uint32_t p41;
    float p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    int32_t p48;
    uint32_t p49;
    uint32_t p50;
    uint32_t p51;
    uint32_t p52;
    uint32_t p53;
    uint32_t p54;
    uint32_t p55;
    uint32_t p56;
    uint32_t p57;
    uint32_t p58;
    uint32_t p59;
    uint32_t p60;
    uint32_t p61;
    uint32_t p62;
    uint32_t p63;
    uint32_t p64;
    uint32_t p65;
    uint32_t p66;
    uint32_t p67;
    uint32_t p68;
    uint32_t p69;
    uint32_t p70;
    uint32_t p71;
    uint32_t p72;
    uint32_t p73;
    uint32_t p74;
    uint32_t p75;
    uint32_t p76;
    uint32_t p77;
    uint32_t p78;
    uint32_t p79;
    uint32_t p80;
    float p81;
    uint32_t p82;
    uint32_t p83;
    uint32_t p84;
    uint32_t p85;
    float p86;
    float p87;
};
    
// Trails
struct s_ooooi4i4_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    int32_t p4;
    int32_t p5;
};
    
// EmitParams
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    int32_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint32_t p29;
    uint32_t p30;
    float p31;
    float p32;
    int32_t p33;
    float p34;
    float p35;
    uint32_t p36;
    bool p37;
    bool p38;
    bool p39;
    bool p40;
    bool p41;
    bool p42;
    bool p43;
    bool p44;
    bool p45;
    bool p46;
    bool p47;
};
    
// Particle
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    int32_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint32_t p29;
    uint32_t p30;
    float p31;
    float p32;
    int32_t p33;
    float p34;
    float p35;
    uint32_t p36;
};
    
// Navigation
struct s_i4boooo_
{
    int32_t p0;
    bool p1;
    void* p2;
    void* p3;
    void* p4;
    void* p5;
};
    
// ColorBlock
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
};
    
// SpriteState
struct s_oooo_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
};
    
// TimeSpan
struct s_i8_
{
    int64_t p0;
};
    
// Void
struct v
{
};
    
// Matrix4x4
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
};
    
// Scene
struct s_i4_
{
    int32_t p0;
};
    
// MainModule
struct s_o_
{
    void* p0;
};
    
// Vector2
struct s_r4r4_
{
    float p0;
    float p1;
};
    
// ReadOnly
struct s_Pvi4pi4i4_
{
    void* p0;
    int32_t p1;
    void* p2;
    int32_t p3;
    int32_t p4;
};
    
// NativeOverlapped
struct s_ppi4i4p_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
    void* p4;
};
    
// Span`1
struct s_pi4_
{
    void* p0;
    int32_t p1;
};
    
// AsyncLocalValueChangedArgs`1
struct s_oob_
{
    void* p0;
    void* p1;
    bool p2;
};
    
// FileSystemEntry
struct s_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_
{
    uint8_t* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    uint32_t p5;
    uint32_t p6;
    int64_t p7;
    int64_t p8;
    int64_t p9;
    int64_t p10;
    int64_t p11;
    int64_t p12;
    int64_t p13;
    int64_t p14;
    int64_t p15;
    int64_t p16;
    int64_t p17;
    uint32_t p18;
    int32_t p19;
    bool p20;
    bool p21;
    bool p22;
    void* p23;
    int32_t p24;
    void* p25;
    int32_t p26;
    void* p27;
    int32_t p28;
    Il2CppChar p29;
    int32_t p30;
    void* p31;
    int32_t p32;
    void* p33;
    int32_t p34;
    void* p35;
    int32_t p36;
};
    
// BatchCullingContext
struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    void* p16;
    int32_t p17;
    void* p18;
    int32_t p19;
    int32_t p20;
    int32_t p21;
    void* p22;
    int32_t p23;
    int32_t p24;
    void* p25;
    int32_t p26;
    void* p27;
    int32_t p28;
    int32_t p29;
    int32_t p30;
    void* p31;
    int32_t p32;
    int32_t p33;
    void* p34;
    int32_t p35;
    int32_t p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    int32_t p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
    float p56;
    float p57;
    float p58;
    float p59;
};
    
// CullingGroupEvent
struct s_i4u1u1_
{
    int32_t p0;
    uint8_t p1;
    uint8_t p2;
};
    
// DebugScreenCapture
struct s_Pvi4i4i4pi4i4oi4i4i4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
};
    
// PhraseRecognizedEventArgs
struct s_i4osu8i8_
{
    int32_t p0;
    void* p1;
    void* p2;
    uint64_t p3;
    int64_t p4;
};
    
// VideoCaptureResult
struct s_i4i8_
{
    int32_t p0;
    int64_t p1;
};
    
// ScriptableRenderContext
struct s_ppi4i4_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
};
    
// RectInt
struct s_i4i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
};
    
// TimerState
struct s_i8i8_
{
    int64_t p0;
    int64_t p1;
};
    
// XRNodeState
struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_
{
    int32_t p0;
    int32_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    int32_t p21;
    uint64_t p22;
};
    
// InputDevice
struct s_u8b_
{
    uint64_t p0;
    bool p1;
};
    
// MeshGenerationResult
struct s_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_
{
    uint64_t p0;
    uint64_t p1;
    void* p2;
    void* p3;
    int32_t p4;
    int32_t p5;
    uint64_t p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
};
    
// BuildPlayerOptions
struct s_ossi4i4i4i4o_
{
    void* p0;
    void* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    void* p7;
};
    
// ModeChangedArgs
struct s_i4i4_
{
    int32_t p0;
    int32_t p1;
};
    
// CameraMode
struct s_i4ss_
{
    int32_t p0;
    void* p1;
    void* p2;
};
    
// ObjectChangeEventStream
struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    void* p16;
    int32_t p17;
};
    
// CacheServerConnectionChangedParameters
struct s__
{
};
    
// ActiveProfileChangedEventArgs
struct s_ss_
{
    void* p0;
    void* p1;
};
    
// ShortcutBindingChangedEventArgs
struct s_soo_
{
    void* p0;
    void* p1;
    void* p2;
};
    
// PlayableGraph
struct s_pu4_
{
    void* p0;
    uint32_t p1;
};
    
// AuthCodeResponse
struct s_so_
{
    void* p0;
    void* p1;
};
    
// ObjectSelectorTargetInfo
struct s_u8u8u4u4u4u4i4oo_
{
    uint64_t p0;
    uint64_t p1;
    uint32_t p2;
    uint32_t p3;
    uint32_t p4;
    uint32_t p5;
    int32_t p6;
    void* p7;
    void* p8;
};
    
// SubSceneInfo
struct s_oi4osi4u1u1u1u1_
{
    void* p0;
    int32_t p1;
    void* p2;
    void* p3;
    int32_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
};
    
// TouchEvent
struct s_i4r4r4i4_
{
    int32_t p0;
    float p1;
    float p2;
    int32_t p3;
};
    
// NodeCreationContext
struct s_r4r4oi4_
{
    float p0;
    float p1;
    void* p2;
    int32_t p3;
};
    
// GraphViewChange
struct s_ooor4r4_
{
    void* p0;
    void* p1;
    void* p2;
    float p3;
    float p4;
};
    
// SearchColumnEventArgs
struct s_oooObr4r4r4r4bb_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    bool p4;
    float p5;
    float p6;
    float p7;
    float p8;
    bool p9;
    bool p10;
};
    
// SearchColumnCompareArgs
struct s_oooObr4r4r4r4bboooObr4r4r4r4bbb_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    bool p4;
    float p5;
    float p6;
    float p7;
    float p8;
    bool p9;
    bool p10;
    void* p11;
    void* p12;
    void* p13;
    void* p14;
    bool p15;
    float p16;
    float p17;
    float p18;
    float p19;
    bool p20;
    bool p21;
    bool p22;
};
    
// SearchEvent
struct s_oo_
{
    void* p0;
    void* p1;
};
    
// UserConfig
struct s_ooo_
{
    void* p0;
    void* p1;
    void* p2;
};
    
// VFXOutputEventArgs
struct s_i4o_
{
    int32_t p0;
    void* p1;
};
    
// EditorCurveBinding
struct s_sosi4i4i4i4i4_
{
    void* p0;
    void* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
};
    
// ParseResult`1
struct s_bo_
{
    bool p0;
    void* p1;
};
    
// Nullable`1
struct s_bi4_
{
    bool p0;
    int32_t p1;
};
    
// Nullable`1
struct s_bi8_
{
    bool p0;
    int64_t p1;
};
    
// Nullable`1
struct s_br4_
{
    bool p0;
    float p1;
};
    
// Nullable`1
struct s_br8_
{
    bool p0;
    double p1;
};
    
// Decimal
struct s_i4i4i4i4u8_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    uint64_t p4;
};
    
// Nullable`1
struct s_bi4i4i4i4u8_
{
    bool p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    uint64_t p5;
};
    


// System.Object get_Target()
static bool w_Ot(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Ot");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object DynamicInvoke(System.Object[])
static bool w_OtVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_OtVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object RunCS(Int32)
static bool w_Oti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Oti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object RunJS(Puerts.JsEnv, Int32)
static bool w_Otoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Otoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// Boolean get_isLoadingLevel()
static bool w_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef bool (*FuncToCall)(const void* method);
    bool ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(System.Object, System.Object)
static bool w_bOO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(System.Object)
static bool w_bTO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bTO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = JsValueToCSRef(context, info.Holder(), GetTypeId(info.Holder()));
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CanStreamedLevelBeLoaded(Int32)
static bool w_bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsPlaying(UnityEngine.Object)
static bool w_bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Object, UnityEngine.Object)
static bool w_boo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CanStreamedLevelBeLoaded(System.String)
static bool w_bs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryParse(System.String, System.DateTime ByRef)
static bool w_bsPs_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bsPs_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Pstruct
    s_u8_* p1 = nullptr; // valuetype ref
    s_u8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_u8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct s_u8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_bs_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Bounds, UnityEngine.Bounds)
static bool w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(System.DateTime, System.DateTime)
static bool w_bs_u8_s_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u8_s_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};
    // JSValToCSVal struct
    s_u8_* pp1 = DataTransfer::GetPointer<s_u8_>(context, info[1]);
    s_u8_ p1 = pp1 ? *pp1 : s_u8_ {};

    typedef bool (*FuncToCall)(struct s_u8_ p0, struct s_u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryParse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)
static bool w_bsoi4Ps_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bsoi4Ps_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal Pstruct
    s_u8_* p3 = nullptr; // valuetype ref
    s_u8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_u8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(void* p0, void* p1, int32_t p2, struct s_u8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)
static bool w_bsooi4Ps_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bsooi4Ps_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal Pstruct
    s_u8_* p4 = nullptr; // valuetype ref
    s_u8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_u8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(void* p0, void* p1, void* p2, int32_t p3, struct s_u8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)
static bool w_bssoi4Ps_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bssoi4Ps_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal Pstruct
    s_u8_* p4 = nullptr; // valuetype ref
    s_u8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_u8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(void* p0, void* p1, void* p2, int32_t p3, struct s_u8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean get_Static()
static bool w_bt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bt");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef bool (*FuncToCall)(void*,const void* method);
    bool ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(System.Object)
static bool w_btO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsAlive(Boolean)
static bool w_btb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,bool p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsChildOf(UnityEngine.Transform)
static bool w_bto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetComponent(System.Type, UnityEngine.Component ByRef)
static bool w_btoPo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef bool (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CompareTag(System.String)
static bool w_bts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Vector3)
static bool w_bts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Bounds)
static bool w_bts_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IntersectRay(UnityEngine.Ray, Single ByRef)
static bool w_bts_r4r4r4r4r4r4_Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, float* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(System.DateTime)
static bool w_bts_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};

    typedef bool (*FuncToCall)(void*,struct s_u8_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Char get_asteriskChar()
static bool w_ct(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ct");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef Il2CppChar (*FuncToCall)(void*,const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 get_streamedBytes()
static bool w_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef int32_t (*FuncToCall)(const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetHashCode()
static bool w_i4T(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4T");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = JsValueToCSRef(context, info.Holder(), GetTypeId(info.Holder()));
    

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UnityEngine.StackTraceLogType GetStackTraceLogType(UnityEngine.LogType)
static bool w_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Add(Int32, Int32)
static bool w_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 AllSelectablesNoAlloc(UnityEngine.UI.Selectable[])
static bool w_i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Compare(System.DateTime, System.DateTime)
static bool w_i4s_u8_s_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_u8_s_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};
    // JSValToCSVal struct
    s_u8_* pp1 = DataTransfer::GetPointer<s_u8_>(context, info[1]);
    s_u8_ p1 = pp1 ? *pp1 : s_u8_ {};

    typedef int32_t (*FuncToCall)(struct s_u8_ p0, struct s_u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// CallTarget get_Target()
static bool w_i4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CompareTo(System.Object)
static bool w_i4tO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetTrails(Trails ByRef)
static bool w_i4tPs_ooooi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tPs_ooooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_ooooi4i4_* p0 = nullptr; // valuetype ref
    s_ooooi4i4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_ooooi4i4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef int32_t (*FuncToCall)(void*,struct s_ooooi4i4_* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Id(Int32)
static bool w_i4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 MAdd(Int32, Int32)
static bool w_i4ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Particle[])
static bool w_i4to(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4to");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Particle[], Int32)
static bool w_i4toi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4toi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Particle[], Int32, Int32)
static bool w_i4toi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4toi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle])
static bool w_i4ts_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32)
static bool w_i4ts_Pvi4i4i4pi4i4oi4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32)
static bool w_i4ts_Pvi4i4i4pi4i4oi4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CompareTo(System.DateTime)
static bool w_i4ts_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_u8_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int64 get_responseCode()
static bool w_i8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int64_t (*FuncToCall)(void*,const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// System.String[] GetBuildTags()
static bool w_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_o");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Type GetType()
static bool w_oT(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oT");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = JsValueToCSRef(context, info.Holder(), GetTypeId(info.Holder()));
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate Combine(System.Delegate[])
static bool w_oVo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AsyncOperation RequestUserAuthorization(UnityEngine.UserAuthorization)
static bool w_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object)
static bool w_oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.Reflection.MethodInfo)
static bool w_ooOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.Reflection.MethodInfo, Boolean)
static bool w_ooOob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String)
static bool w_ooOs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String, Boolean)
static bool w_ooOsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String, Boolean, Boolean)
static bool w_ooOsbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOsbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsOfType(System.Type, Boolean)
static bool w_oob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsSortMode)
static bool w_ooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsInactive, UnityEngine.FindObjectsSortMode)
static bool w_ooi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform)
static bool w_ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform, Boolean)
static bool w_ooob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest Post(System.Uri, System.Collections.Generic.List`1[UnityEngine.Networking.IMultipartFormSection], Byte[])
static bool w_oooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Type, System.String)
static bool w_ooos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Type, System.String, Boolean)
static bool w_ooosb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooosb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Type, System.String, Boolean, Boolean)
static bool w_ooosbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooosbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest Put(System.Uri, System.String)
static bool w_oos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_oos_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Transform)
static bool w_oos_r4r4r4_s_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4_s_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.GameObject FindWithTag(System.String)
static bool w_os(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest Put(System.String, Byte[])
static bool w_oso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest Post(System.String, System.Collections.Generic.List`1[UnityEngine.Networking.IMultipartFormSection], Byte[])
static bool w_osoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest Put(System.String, System.String)
static bool w_oss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Transform get_parent()
static bool w_ot(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ot");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.String[] GetDateTimeFormats(Char)
static bool w_otc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otc");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,Il2CppChar p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.String[] GetDateTimeFormats(Char, System.IFormatProvider)
static bool w_otco(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otco");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,Il2CppChar p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Transform GetChild(Int32)
static bool w_oti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Component GetComponent(System.Type)
static bool w_oto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Component GetComponentInChildren(System.Type, Boolean)
static bool w_otob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Transform Find(System.String)
static bool w_ots(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.UI.Selectable FindSelectable(UnityEngine.Vector3)
static bool w_ots_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void* (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Single Payload()
static bool w_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef float (*FuncToCall)(const void* method);
    float ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Payload(Int32, Int32, Single)
static bool w_r4i4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4i4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef float (*FuncToCall)(int32_t p0, int32_t p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Magnitude(UnityEngine.Vector3)
static bool w_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_r4s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SignedAngle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Payload()
static bool w_r4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef float (*FuncToCall)(void*,const void* method);
    float ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single get_Item(Int32)
static bool w_r4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(void*,int32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Payload(Int32, Int32, Single)
static bool w_r4ti4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ti4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef float (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SqrDistance(UnityEngine.Vector3)
static bool w_r4ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double get_timeAsDouble()
static bool w_r8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef double (*FuncToCall)(const void* method);
    double ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double ToOADate()
static bool w_r8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef double (*FuncToCall)(void*,const void* method);
    double ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// System.String get_buildGUID()
static bool w_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString()
static bool w_sT(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sT");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = JsValueToCSRef(context, info.Holder(), GetTypeId(info.Holder()));
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// ReadOnly get_nativeData()
static bool w_s_Pvi4pi4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Pvi4pi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_Pvi4pi4i4_ (*FuncToCall)(void*,const void* method);
    struct s_Pvi4pi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.SceneManagement.Scene get_scene()
static bool w_s_i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.UI.Navigation get_navigation()
static bool w_s_i4boooo_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4boooo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4boooo_ (*FuncToCall)(void*,const void* method);
    struct s_i4boooo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.TimeSpan op_Subtraction(System.DateTime, System.DateTime)
static bool w_s_i8_s_u8_s_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_s_u8_s_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};
    // JSValToCSVal struct
    s_u8_* pp1 = DataTransfer::GetPointer<s_u8_>(context, info[1]);
    s_u8_ p1 = pp1 ? *pp1 : s_u8_ {};

    typedef struct s_i8_ (*FuncToCall)(struct s_u8_ p0, struct s_u8_ p1, const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.TimeSpan get_TimeOfDay()
static bool w_s_i8_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i8_ (*FuncToCall)(void*,const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.TimeSpan Subtract(System.DateTime)
static bool w_s_i8_ts_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_ts_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};

    typedef struct s_i8_ (*FuncToCall)(void*,struct s_u8_ p0, const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// MainModule get_main()
static bool w_s_o_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_o_ (*FuncToCall)(void*,const void* method);
    struct s_o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.UI.SpriteState get_spriteState()
static bool w_s_oooo_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oooo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oooo_ (*FuncToCall)(void*,const void* method);
    struct s_oooo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Trails GetTrails()
static bool w_s_ooooi4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ooooi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_ooooi4i4_ (*FuncToCall)(void*,const void* method);
    struct s_ooooi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 get_renderingDisplaySize()
static bool w_s_r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 get_zero()
static bool w_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Multiply(Single, UnityEngine.Vector3)
static bool w_s_r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Normalize(UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ClampMagnitude(UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Scale(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, float p4, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Lerp(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 RotateTowards(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, float p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 get_normalized()
static bool w_s_r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 TransformDirection(Single, Single, Single)
static bool w_s_r4r4r4_tr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ClosestPoint(UnityEngine.Vector3)
static bool w_s_r4r4r4_ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// PlaybackState GetPlaybackState()
static bool w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 V4Ret()
static bool w_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion get_rotation()
static bool w_s_r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Bounds BoundsRet()
static bool w_s_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 get_worldToLocalMatrix()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.UI.ColorBlock get_colors()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime get_Now()
static bool w_s_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_u8_ (*FuncToCall)(const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime FromBinary(Int64)
static bool w_s_u8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef struct s_u8_ (*FuncToCall)(int64_t p0, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime FromOADate(Double)
static bool w_s_u8_r8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<double>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(context, info[0]);

    typedef struct s_u8_ (*FuncToCall)(double p0, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime Parse(System.String)
static bool w_s_u8_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_u8_ (*FuncToCall)(void* p0, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime SpecifyKind(System.DateTime, System.DateTimeKind)
static bool w_s_u8_s_u8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_s_u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_u8_ (*FuncToCall)(struct s_u8_ p0, int32_t p1, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime op_Addition(System.DateTime, System.TimeSpan)
static bool w_s_u8_s_u8_s_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_s_u8_s_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};
    // JSValToCSVal struct
    s_i8_* pp1 = DataTransfer::GetPointer<s_i8_>(context, info[1]);
    s_i8_ p1 = pp1 ? *pp1 : s_i8_ {};

    typedef struct s_u8_ (*FuncToCall)(struct s_u8_ p0, struct s_i8_ p1, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime Parse(System.String, System.IFormatProvider)
static bool w_s_u8_so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_u8_ (*FuncToCall)(void* p0, void* p1, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime Parse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles)
static bool w_s_u8_soi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_soi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef struct s_u8_ (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime ParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles)
static bool w_s_u8_sooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_sooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef struct s_u8_ (*FuncToCall)(void* p0, void* p1, void* p2, int32_t p3, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime ParseExact(System.String, System.String, System.IFormatProvider)
static bool w_s_u8_sso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef struct s_u8_ (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime ParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles)
static bool w_s_u8_ssoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_ssoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef struct s_u8_ (*FuncToCall)(void* p0, void* p1, void* p2, int32_t p3, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime get_Date()
static bool w_s_u8_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_u8_ (*FuncToCall)(void*,const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime AddMonths(Int32)
static bool w_s_u8_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_u8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime AddTicks(Int64)
static bool w_s_u8_ti8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_ti8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef struct s_u8_ (*FuncToCall)(void*,int64_t p0, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime AddDays(Double)
static bool w_s_u8_tr8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_tr8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<double>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(context, info[0]);

    typedef struct s_u8_ (*FuncToCall)(void*,double p0, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.DateTime Add(System.TimeSpan)
static bool w_s_u8_ts_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8_ts_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8_* pp0 = DataTransfer::GetPointer<s_i8_>(context, info[0]);
    s_i8_ p0 = pp0 ? *pp0 : s_i8_ {};

    typedef struct s_u8_ (*FuncToCall)(void*,struct s_i8_ p0, const void* method);
    struct s_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.String EscapeURL(System.String)
static bool w_ss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String EscapeURL(System.String, System.Text.Encoding)
static bool w_sso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String get_Method()
static bool w_st(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_st");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString(System.IFormatProvider)
static bool w_sto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString(System.String)
static bool w_sts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString(System.String, System.IFormatProvider)
static bool w_stso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// UInt32 get_randomSeed()
static bool w_u4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint32_t (*FuncToCall)(void*,const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt64 get_sceneCullingMask()
static bool w_u8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint64_t (*FuncToCall)(void*,const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
    return true;
}

// Void Payload()
static bool w_v(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_v");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void (*FuncToCall)(const void* method);
    ((FuncToCall)methodPointer)(  method);

    
    return true;
}

// Void Log(System.Object)
static bool w_vO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Log(System.Object, UnityEngine.Object)
static bool w_vOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)
static bool w_vPs_r4r4r4_Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)
static bool w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_r4r4r4_* p1, struct s_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void set_runInBackground(Boolean)
static bool w_vb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(bool p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Assert(Boolean, System.Object)
static bool w_vbO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbO");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Assert(Boolean, System.Object, UnityEngine.Object)
static bool w_vbOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbOo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Assert(Boolean, UnityEngine.Object)
static bool w_vbo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertFormat(Boolean, UnityEngine.Object, System.String, System.Object[])
static bool w_vbosVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbosVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal ref params
    void* p3 = RestArguments<void*>::PackRef(context, info, TIp3, 3);
                

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Assert(Boolean, System.String)
static bool w_vbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertFormat(Boolean, System.String, System.Object[])
static bool w_vbsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbsVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Assert(Boolean, System.String, UnityEngine.Object)
static bool w_vbso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbso");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Payload(Int32)
static bool w_vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(int32_t p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetStackTraceLogType(UnityEngine.LogType, UnityEngine.StackTraceLogType)
static bool w_vi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.LogType, UnityEngine.LogOption, UnityEngine.Object, System.String, System.Object[])
static bool w_vi4i4osVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4osVO");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal s
    v8::String::Utf8Value tp3(isolate, info[3]);
    void* p3 = CStringToCSharpString(*tp3);
    // JSValToCSVal ref params
    void* p4 = RestArguments<void*>::PackRef(context, info, TIp4, 4);
                

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Payload(Int32, Int32, Single)
static bool w_vi4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Payload(UnityEngine.Transform)
static bool w_vo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void DestroyImmediate(UnityEngine.Object, Boolean)
static bool w_vob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LogException(System.Exception, UnityEngine.Object)
static bool w_voo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Destroy(UnityEngine.Object, Single)
static bool w_vor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Payload(UnityEngine.Transform, Single, Single, Single)
static bool w_vor4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vor4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.Object, System.String, System.Object[])
static bool w_vosVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vosVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Payload(UnityEngine.Transform, UnityEngine.Vector3)
static bool w_vos_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void set_fixedDeltaTime(Single)
static bool w_vr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(float p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void OpenURL(System.String)
static bool w_vs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void LogFormat(System.String, System.Object[])
static bool w_vsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void VecTest(UnityEngine.Vector3)
static bool w_vs_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vs_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single, Boolean)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Payload()
static bool w_vt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vt");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void (*FuncToCall)(void*,const void* method);
    ((FuncToCall)methodPointer)(self,  method);

    
    return true;
}

// Void OptionalTest1(Int32)
static bool w_vtDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,int32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void OptionalTest3(System.String)
static bool w_vtDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal string  with default
    void* p0 = OptionalParameter<void*>::GetString(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void OptionalTest2(UnityEngine.Vector3)
static bool w_vtDs_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDs_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && (!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal valuetype  with default
    s_r4r4r4_ p0 = OptionalParameter<s_r4r4r4_>::GetValueType(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void TestObject(System.Object)
static bool w_vtO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ObjRef(System.Object ByRef)
static bool w_vtPO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Po/PO
    void* up0 = nullptr; // object ref
    void** p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        up0 = JsValueToCSRef(context, tp0, TIp0);
    }
        

    typedef void (*FuncToCall)(void*,void** p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, CSAnyToJsValue(isolate, context, *p0));
    }
    
    return true;
}

// Void IntRef(Int32 ByRef)
static bool w_vtPi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[0]);
    int32_t* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void*,int32_t* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p0));
    }
    
    return true;
}

// Void GetPositionAndRotation(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef)
static bool w_vtPs_r4r4r4_Ps_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_r4r4r4_Ps_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_* p0, struct s_r4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void TestParams4(System.Object[])
static bool w_vtVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtVO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void TestParams3(UnityEngine.Vector3[])
static bool w_vtVs_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtVs_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal valuetype params
    void* p0 = RestArguments<s_r4r4r4_>::PackValueType(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_hasChanged(Boolean)
static bool w_vtb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,bool p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Stop(Boolean, UnityEngine.ParticleSystemStopBehavior)
static bool w_vtbi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_asteriskChar(Char)
static bool w_vtc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtc");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,Il2CppChar p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void TestEnumShort(ESSS)
static bool w_vti2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti2");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int16_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int16_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void CheckEnumGen(ESSS, EIII, ESSS, EIII, ESSS, EIII)
static bool w_vti2i4i2i4i2i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti2i4i2i4i2i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int16_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int16_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int16_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int16_t p4 = converter::Converter<int16_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,int16_t p0, int32_t p1, int16_t p2, int32_t p3, int16_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Payload(Int32)
static bool w_vti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Int32, Int32)
static bool w_vti4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void DefaultTest(Int32, Double)
static bool w_vti4Dr8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Dr8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<double>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    double p1 = OptionalParameter<double>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, double p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void TriggerSubEmitter(Int32, Particle ByRef)
static bool w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void TestParams2(Int32, Int32[])
static bool w_vti4Vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Vi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive params
    void* p1 = RestArguments<int32_t>::PackPrimitive(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void TestParams1(Int32, System.String[])
static bool w_vti4Vs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Vs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal string params
    void* p1 = RestArguments<void*>::PackString(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32)
static bool w_vti4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32)
static bool w_vti4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, System.DateTimeKind)
static bool w_vti4i4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.DateTimeKind)
static bool w_vti4i4i4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar)
static bool w_vti4i4i4i4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4o");
    
    auto TIp7 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, void* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar, System.DateTimeKind)
static bool w_vti4i4i4i4i4i4i4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4oi4");
    
    auto TIp7 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, void* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar)
static bool w_vti4i4i4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4o");
    
    auto TIp6 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, System.Globalization.Calendar)
static bool w_vti4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Payload(Int32, Int32, Single)
static bool w_vti4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void TriggerSubEmitter(Int32, System.Collections.Generic.List`1[UnityEngine.ParticleSystem+Particle])
static bool w_vti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Item(Int32, Single)
static bool w_vti4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int64)
static bool w_vti8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int64_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Int64, System.DateTimeKind)
static bool w_vti8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int64_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Payload(UnityEngine.Transform)
static bool w_vto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetParent(UnityEngine.Transform, Boolean)
static bool w_vtob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Particle[], Int32)
static bool w_vtoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Particle[], Int32, Int32)
static bool w_vtoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetComponents(System.Type, System.Collections.Generic.List`1[UnityEngine.Component])
static bool w_vtoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Payload(UnityEngine.Transform, Single, Single, Single)
static bool w_vtor4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtor4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.Uri, System.String)
static bool w_vtos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
static bool w_vtos_Oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_Oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_Oi4_* pp1 = DataTransfer::GetPointer<s_Oi4_>(context, info[1]);
    s_Oi4_ p1 = pp1 ? *pp1 : s_Oi4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_Oi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Payload(UnityEngine.Transform, UnityEngine.Vector3)
static bool w_vtos_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Uri, System.String, UnityEngine.Networking.DownloadHandler, UnityEngine.Networking.UploadHandler)
static bool w_vtosoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Expand(Single)
static bool w_vtr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,float p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Simulate(Single, Boolean)
static bool w_vtr4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Simulate(Single, Boolean, Boolean)
static bool w_vtr4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Simulate(Single, Boolean, Boolean, Boolean)
static bool w_vtr4bbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4bbb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Single, Single)
static bool w_vtr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Set(Single, Single, Single)
static bool w_vtr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Translate(Single, Single, Single, UnityEngine.Space)
static bool w_vtr4r4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Translate(Single, Single, Single, UnityEngine.Transform)
static bool w_vtr4r4r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_tag(System.String)
static bool w_vts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, System.Object)
static bool w_vtsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, System.Object, UnityEngine.SendMessageOptions)
static bool w_vtsOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.String, System.Type[])
static bool w_vtsVo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle])
static bool w_vts_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32)
static bool w_vts_Pvi4i4i4pi4i4oi4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32)
static bool w_vts_Pvi4i4i4pi4i4oi4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_navigation(UnityEngine.UI.Navigation)
static bool w_vts_i4boooo_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4boooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4boooo_* pp0 = DataTransfer::GetPointer<s_i4boooo_>(context, info[0]);
    s_i4boooo_ p0 = pp0 ? *pp0 : s_i4boooo_ {};

    typedef void (*FuncToCall)(void*,struct s_i4boooo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_spriteState(UnityEngine.UI.SpriteState)
static bool w_vts_oooo_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_oooo_* pp0 = DataTransfer::GetPointer<s_oooo_>(context, info[0]);
    s_oooo_ p0 = pp0 ? *pp0 : s_oooo_ {};

    typedef void (*FuncToCall)(void*,struct s_oooo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTrails(Trails)
static bool w_vts_ooooi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_ooooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_ooooi4i4_* pp0 = DataTransfer::GetPointer<s_ooooi4i4_>(context, info[0]);
    s_ooooi4i4_ p0 = pp0 ? *pp0 : s_ooooi4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_ooooi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Scale(UnityEngine.Vector3)
static bool w_vts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Space)
static bool w_vts_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Transform)
static bool w_vts_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Rotate(UnityEngine.Vector3, Single)
static bool w_vts_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Rotate(UnityEngine.Vector3, Single, UnityEngine.Space)
static bool w_vts_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetMinMax(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vts_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void RotateAround(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_vts_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPositionAndRotation(UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_vts_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetPlaybackState(PlaybackState)
static bool w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_>(context, info[0]);
    s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_rotation(UnityEngine.Quaternion)
static bool w_vts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Encapsulate(UnityEngine.Bounds)
static bool w_vts_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_colors(UnityEngine.UI.ColorBlock)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Emit(EmitParams, Int32)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void TestDateTime1234(System.DateTime)
static bool w_vts_u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8_* pp0 = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p0 = pp0 ? *pp0 : s_u8_ {};

    typedef void (*FuncToCall)(void*,struct s_u8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, UnityEngine.SendMessageOptions)
static bool w_vtsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetRequestHeader(System.String, System.String)
static bool w_vtss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.String, System.String, UnityEngine.Networking.DownloadHandler, UnityEngine.Networking.UploadHandler)
static bool w_vtssoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtssoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_randomSeed(UInt32)
static bool w_vtu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,uint32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

static WrapFuncInfo g_wrapFuncInfos[] = {
    
    {"Ot", w_Ot},
    {"OtVO", w_OtVO},
    {"Oti4", w_Oti4},
    {"Otoi4", w_Otoi4},
    {"b", w_b},
    {"bOO", w_bOO},
    {"bTO", w_bTO},
    {"bi4", w_bi4},
    {"bo", w_bo},
    {"boo", w_boo},
    {"bs", w_bs},
    {"bsPs_u8_", w_bsPs_u8_},
    {"bs_r4r4r4_s_r4r4r4_", w_bs_r4r4r4_s_r4r4r4_},
    {"bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_},
    {"bs_u8_s_u8_", w_bs_u8_s_u8_},
    {"bsoi4Ps_u8_", w_bsoi4Ps_u8_},
    {"bsooi4Ps_u8_", w_bsooi4Ps_u8_},
    {"bssoi4Ps_u8_", w_bssoi4Ps_u8_},
    {"bt", w_bt},
    {"btO", w_btO},
    {"btb", w_btb},
    {"bto", w_bto},
    {"btoPo", w_btoPo},
    {"bts", w_bts},
    {"bts_r4r4r4_", w_bts_r4r4r4_},
    {"bts_r4r4r4r4r4r4_", w_bts_r4r4r4r4r4r4_},
    {"bts_r4r4r4r4r4r4_Pr4", w_bts_r4r4r4r4r4r4_Pr4},
    {"bts_u8_", w_bts_u8_},
    {"ct", w_ct},
    {"i4", w_i4},
    {"i4T", w_i4T},
    {"i4i4", w_i4i4},
    {"i4i4i4", w_i4i4i4},
    {"i4o", w_i4o},
    {"i4s_u8_s_u8_", w_i4s_u8_s_u8_},
    {"i4t", w_i4t},
    {"i4tO", w_i4tO},
    {"i4tPs_ooooi4i4_", w_i4tPs_ooooi4i4_},
    {"i4ti4", w_i4ti4},
    {"i4ti4i4", w_i4ti4i4},
    {"i4to", w_i4to},
    {"i4toi4", w_i4toi4},
    {"i4toi4i4", w_i4toi4i4},
    {"i4ts_Pvi4i4i4pi4i4oi4_", w_i4ts_Pvi4i4i4pi4i4oi4_},
    {"i4ts_Pvi4i4i4pi4i4oi4_i4", w_i4ts_Pvi4i4i4pi4i4oi4_i4},
    {"i4ts_Pvi4i4i4pi4i4oi4_i4i4", w_i4ts_Pvi4i4i4pi4i4oi4_i4i4},
    {"i4ts_u8_", w_i4ts_u8_},
    {"i8t", w_i8t},
    {"o", w_o},
    {"oT", w_oT},
    {"oVo", w_oVo},
    {"oi4", w_oi4},
    {"oo", w_oo},
    {"ooOo", w_ooOo},
    {"ooOob", w_ooOob},
    {"ooOs", w_ooOs},
    {"ooOsb", w_ooOsb},
    {"ooOsbb", w_ooOsbb},
    {"oob", w_oob},
    {"ooi4", w_ooi4},
    {"ooi4i4", w_ooi4i4},
    {"ooo", w_ooo},
    {"ooob", w_ooob},
    {"oooo", w_oooo},
    {"ooos", w_ooos},
    {"ooosb", w_ooosb},
    {"ooosbb", w_ooosbb},
    {"oos", w_oos},
    {"oos_r4r4r4_s_r4r4r4r4_", w_oos_r4r4r4_s_r4r4r4r4_},
    {"oos_r4r4r4_s_r4r4r4r4_o", w_oos_r4r4r4_s_r4r4r4r4_o},
    {"os", w_os},
    {"oso", w_oso},
    {"osoo", w_osoo},
    {"oss", w_oss},
    {"ot", w_ot},
    {"otc", w_otc},
    {"otco", w_otco},
    {"oti4", w_oti4},
    {"oto", w_oto},
    {"otob", w_otob},
    {"ots", w_ots},
    {"ots_r4r4r4_", w_ots_r4r4r4_},
    {"r4", w_r4},
    {"r4i4i4r4", w_r4i4i4r4},
    {"r4s_r4r4r4_", w_r4s_r4r4r4_},
    {"r4s_r4r4r4_s_r4r4r4_", w_r4s_r4r4r4_s_r4r4r4_},
    {"r4s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"r4t", w_r4t},
    {"r4ti4", w_r4ti4},
    {"r4ti4i4r4", w_r4ti4i4r4},
    {"r4ts_r4r4r4_", w_r4ts_r4r4r4_},
    {"r8", w_r8},
    {"r8t", w_r8t},
    {"s", w_s},
    {"sT", w_sT},
    {"s_Pvi4pi4i4_t", w_s_Pvi4pi4i4_t},
    {"s_i4_t", w_s_i4_t},
    {"s_i4boooo_t", w_s_i4boooo_t},
    {"s_i8_s_u8_s_u8_", w_s_i8_s_u8_s_u8_},
    {"s_i8_t", w_s_i8_t},
    {"s_i8_ts_u8_", w_s_i8_ts_u8_},
    {"s_o_t", w_s_o_t},
    {"s_oooo_t", w_s_oooo_t},
    {"s_ooooi4i4_t", w_s_ooooi4i4_t},
    {"s_r4r4_t", w_s_r4r4_t},
    {"s_r4r4r4_", w_s_r4r4r4_},
    {"s_r4r4r4_r4s_r4r4r4_", w_s_r4r4r4_r4s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4},
    {"s_r4r4r4_t", w_s_r4r4r4_t},
    {"s_r4r4r4_tr4r4r4", w_s_r4r4r4_tr4r4r4},
    {"s_r4r4r4_ts_r4r4r4_", w_s_r4r4r4_ts_r4r4r4_},
    {"s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t", w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t},
    {"s_r4r4r4r4_", w_s_r4r4r4r4_},
    {"s_r4r4r4r4_t", w_s_r4r4r4r4_t},
    {"s_r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t},
    {"s_u8_", w_s_u8_},
    {"s_u8_i8", w_s_u8_i8},
    {"s_u8_r8", w_s_u8_r8},
    {"s_u8_s", w_s_u8_s},
    {"s_u8_s_u8_i4", w_s_u8_s_u8_i4},
    {"s_u8_s_u8_s_i8_", w_s_u8_s_u8_s_i8_},
    {"s_u8_so", w_s_u8_so},
    {"s_u8_soi4", w_s_u8_soi4},
    {"s_u8_sooi4", w_s_u8_sooi4},
    {"s_u8_sso", w_s_u8_sso},
    {"s_u8_ssoi4", w_s_u8_ssoi4},
    {"s_u8_t", w_s_u8_t},
    {"s_u8_ti4", w_s_u8_ti4},
    {"s_u8_ti8", w_s_u8_ti8},
    {"s_u8_tr8", w_s_u8_tr8},
    {"s_u8_ts_i8_", w_s_u8_ts_i8_},
    {"ss", w_ss},
    {"sso", w_sso},
    {"st", w_st},
    {"sto", w_sto},
    {"sts", w_sts},
    {"stso", w_stso},
    {"u4t", w_u4t},
    {"u8t", w_u8t},
    {"v", w_v},
    {"vO", w_vO},
    {"vOo", w_vOo},
    {"vPs_r4r4r4_Ps_r4r4r4_", w_vPs_r4r4r4_Ps_r4r4r4_},
    {"vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_", w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_},
    {"vb", w_vb},
    {"vbO", w_vbO},
    {"vbOo", w_vbOo},
    {"vbo", w_vbo},
    {"vbosVO", w_vbosVO},
    {"vbs", w_vbs},
    {"vbsVO", w_vbsVO},
    {"vbso", w_vbso},
    {"vi4", w_vi4},
    {"vi4i4", w_vi4i4},
    {"vi4i4osVO", w_vi4i4osVO},
    {"vi4i4r4", w_vi4i4r4},
    {"vo", w_vo},
    {"vob", w_vob},
    {"voo", w_voo},
    {"vor4", w_vor4},
    {"vor4r4r4", w_vor4r4r4},
    {"vosVO", w_vosVO},
    {"vos_r4r4r4_", w_vos_r4r4r4_},
    {"vr4", w_vr4},
    {"vs", w_vs},
    {"vsVO", w_vsVO},
    {"vs_r4r4r4_", w_vs_r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_", w_vs_r4r4r4_s_r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b},
    {"vt", w_vt},
    {"vtDi4", w_vtDi4},
    {"vtDs", w_vtDs},
    {"vtDs_r4r4r4_", w_vtDs_r4r4r4_},
    {"vtO", w_vtO},
    {"vtPO", w_vtPO},
    {"vtPi4", w_vtPi4},
    {"vtPs_r4r4r4_Ps_r4r4r4r4_", w_vtPs_r4r4r4_Ps_r4r4r4r4_},
    {"vtVO", w_vtVO},
    {"vtVs_r4r4r4_", w_vtVs_r4r4r4_},
    {"vtb", w_vtb},
    {"vtbi4", w_vtbi4},
    {"vtc", w_vtc},
    {"vti2", w_vti2},
    {"vti2i4i2i4i2i4", w_vti2i4i2i4i2i4},
    {"vti4", w_vti4},
    {"vti4Di4", w_vti4Di4},
    {"vti4Dr8", w_vti4Dr8},
    {"vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_", w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_},
    {"vti4Vi4", w_vti4Vi4},
    {"vti4Vs", w_vti4Vs},
    {"vti4i4i4", w_vti4i4i4},
    {"vti4i4i4i4i4i4", w_vti4i4i4i4i4i4},
    {"vti4i4i4i4i4i4i4", w_vti4i4i4i4i4i4i4},
    {"vti4i4i4i4i4i4i4i4", w_vti4i4i4i4i4i4i4i4},
    {"vti4i4i4i4i4i4i4o", w_vti4i4i4i4i4i4i4o},
    {"vti4i4i4i4i4i4i4oi4", w_vti4i4i4i4i4i4i4oi4},
    {"vti4i4i4i4i4i4o", w_vti4i4i4i4i4i4o},
    {"vti4i4i4o", w_vti4i4i4o},
    {"vti4i4r4", w_vti4i4r4},
    {"vti4o", w_vti4o},
    {"vti4r4", w_vti4r4},
    {"vti8", w_vti8},
    {"vti8i4", w_vti8i4},
    {"vto", w_vto},
    {"vtob", w_vtob},
    {"vtoi4", w_vtoi4},
    {"vtoi4i4", w_vtoi4i4},
    {"vtoo", w_vtoo},
    {"vtor4r4r4", w_vtor4r4r4},
    {"vtos", w_vtos},
    {"vtos_Oi4_", w_vtos_Oi4_},
    {"vtos_r4r4r4_", w_vtos_r4r4r4_},
    {"vtosoo", w_vtosoo},
    {"vtr4", w_vtr4},
    {"vtr4b", w_vtr4b},
    {"vtr4bb", w_vtr4bb},
    {"vtr4bbb", w_vtr4bbb},
    {"vtr4r4", w_vtr4r4},
    {"vtr4r4r4", w_vtr4r4r4},
    {"vtr4r4r4i4", w_vtr4r4r4i4},
    {"vtr4r4r4o", w_vtr4r4r4o},
    {"vts", w_vts},
    {"vtsO", w_vtsO},
    {"vtsOi4", w_vtsOi4},
    {"vtsVo", w_vtsVo},
    {"vts_Pvi4i4i4pi4i4oi4_", w_vts_Pvi4i4i4pi4i4oi4_},
    {"vts_Pvi4i4i4pi4i4oi4_i4", w_vts_Pvi4i4i4pi4i4oi4_i4},
    {"vts_Pvi4i4i4pi4i4oi4_i4i4", w_vts_Pvi4i4i4pi4i4oi4_i4i4},
    {"vts_i4boooo_", w_vts_i4boooo_},
    {"vts_oooo_", w_vts_oooo_},
    {"vts_ooooi4i4_", w_vts_ooooi4i4_},
    {"vts_r4r4r4_", w_vts_r4r4r4_},
    {"vts_r4r4r4_i4", w_vts_r4r4r4_i4},
    {"vts_r4r4r4_o", w_vts_r4r4r4_o},
    {"vts_r4r4r4_r4", w_vts_r4r4r4_r4},
    {"vts_r4r4r4_r4i4", w_vts_r4r4r4_r4i4},
    {"vts_r4r4r4_s_r4r4r4_", w_vts_r4r4r4_s_r4r4r4_},
    {"vts_r4r4r4_s_r4r4r4_r4", w_vts_r4r4r4_s_r4r4r4_r4},
    {"vts_r4r4r4_s_r4r4r4r4_", w_vts_r4r4r4_s_r4r4r4r4_},
    {"vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_", w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_},
    {"vts_r4r4r4r4_", w_vts_r4r4r4r4_},
    {"vts_r4r4r4r4r4r4_", w_vts_r4r4r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4},
    {"vts_u8_", w_vts_u8_},
    {"vtsi4", w_vtsi4},
    {"vtss", w_vtss},
    {"vtssoo", w_vtssoo},
    {"vtu4", w_vtu4},
    {nullptr, nullptr}
};


static void* b_O(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_O");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_OO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OVO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_OVO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    auto arrayLength = GetArrayLength(p0);
    v8::Local<v8::Value> *Argv = (v8::Local<v8::Value> *)alloca(sizeof(v8::Local<v8::Value>) * (0 + arrayLength));
    memset(Argv, 0, sizeof(v8::Local<v8::Value>) * (0 + arrayLength));
    
    RestArguments<void*>::UnPackRefOrBoxedValueType(context, p0, arrayLength, TIp0, Argv + 0);
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1 + arrayLength - 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oi4popb(void* target, int32_t p0, void* p1, void* p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_Oi4popb");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_Oo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Ooo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Ooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Oooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Opi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Opi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Opi4O(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Opi4O");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oppi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Oppi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Os_oooObr4r4r4r4bb_(void* target, struct s_oooObr4r4r4r4bb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_Os_oooObr4r4r4r4bb_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Oso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static bool b_b(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bO");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bOooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bOooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bPs(void* target, void** p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bPs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bPs_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_(void* target, struct s_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bPs_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bb(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bb");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bi4i4i4po(void* target, int32_t p0, int32_t p1, int32_t p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bi4i4i4po");

    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bo");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boPi4(void* target, void* p0, int32_t* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boPi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boPsPs(void* target, void* p0, void** p1, void** p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boPsPs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boi4O(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boi4O");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_booi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_booi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_boooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_booso(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_booso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bososo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bososo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bosso(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bosso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bosss(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bosss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bossss(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bossss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bp");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bpi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bpi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bsO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_i4ss_(void* target, struct s_i4ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_i4ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_(void* target, struct s_r4r4_ p0, struct s_r4r4r4_* p1, struct s_r4r4r4_* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_u8_(void* target, struct s_u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_u8u8u4u4u4u4i4oo_oo(void* target, struct s_u8u8u4u4u4u4i4oo_ p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_u8u8u4u4u4u4i4oo_oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsbi4s(void* target, void* p0, bool p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bsbi4s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bsooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bu1o(void* target, uint8_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bu1o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<uint8_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static Il2CppChar b_csi4c(void* target, void* p0, int32_t p1, Il2CppChar p2, void* method) {
    // PLog(LogLevel::Log, "Running b_csi4c");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<Il2CppChar>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    Il2CppChar ret = converter::Converter<Il2CppChar>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int16_t b_i2os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i2os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int16_t ret = converter::Converter<int16_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4i4(void* target, int32_t p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4i4ob(void* target, int32_t p0, int32_t p1, void* p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4i4ob");

    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4sb(void* target, int32_t p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4sb");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ob");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4os_r4r4r4_s_r4r4_ob(void* target, void* p0, struct s_r4r4r4_ p1, struct s_r4r4_ p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_i4os_r4r4r4_s_r4r4_ob");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        CSRefToJsValue(isolate, context, p3),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4p(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4p");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_(void* target, struct s_oooObr4r4r4r4bboooObr4r4r4r4bbb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int64_t b_i8o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i8o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int64_t ret = converter::Converter<int64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int64_t b_i8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int64_t ret = converter::Converter<int64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_o(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_o");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oOo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOs(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oOs");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOsooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oOsooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oPs(void* target, void** p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oPs");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oPs_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_(void* target, struct s_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oPs_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4o(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4o");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4oo(void* target, int32_t p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4oo");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4popb(void* target, int32_t p0, void* p1, void* p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4popb");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4s(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4s");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi8oo(void* target, int64_t p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oi8oo");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4s_r4r4_ooPi4(void* target, void* p0, int32_t p1, struct s_r4r4_ p2, void* p3, void* p4, int32_t* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4s_r4r4_ooPi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooO(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooi8o(void* target, void* p0, void* p1, int64_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_oooi8o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooO(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooO(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[9]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 9, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[10]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 10, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[11]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 11, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[12]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 12, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[13]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 13, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[14]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 14, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[15]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 15, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* p15, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);
    auto TIp15 = GetParameterType(method, 15);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[16]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14),
        CSRefToJsValue(isolate, context, p15)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 16, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooor4(void* target, void* p0, void* p1, float p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooor4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<float>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooos_r4r4_i4(void* target, void* p0, void* p1, struct s_r4r4_ p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooos_r4r4_i4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oos");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oos_ooo_(void* target, void* p0, struct s_ooo_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oos_ooo_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oosb(void* target, void* p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oosb");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oosu8(void* target, void* p0, void* p1, uint64_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oosu8");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<uint64_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oou4u4(void* target, void* p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oou4u4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_opi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_opi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_os");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_osi4o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_osooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oss");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_pp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_pp");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    void* ret = DataTransfer::GetPointer<void>(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_pppi4i8(void* target, void* p0, void* p1, int32_t p2, int64_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_pppi4i8");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p2),
        converter::Converter<int64_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    void* ret = DataTransfer::GetPointer<void>(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4i4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4i4i4r4(void* target, int32_t p0, int32_t p1, float p2, void* method) {
    // PLog(LogLevel::Log, "Running b_r4i4i4r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<float>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4r4(void* target, float p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<float>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4r4Ps_r4r4r4r4_(void* target, float p0, struct s_r4r4r4r4_* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r4r4Ps_r4r4r4r4_");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<float>::toScript(context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4s_r4r4r4_(void* target, struct s_r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4s_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_r8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r8o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_s(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_sO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static struct s__ b_s__(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s__");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s__* pret = DataTransfer::GetPointer<s__>(context, MaybeRet.ToLocalChecked());
    s__ ret = pret ? *pret : s__ {};
    return ret;
        
}

static struct s_bi4_ b_s_bi4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi4_* pret = DataTransfer::GetPointer<s_bi4_>(context, MaybeRet.ToLocalChecked());
    s_bi4_ ret = pret ? *pret : s_bi4_ {};
    return ret;
        
}

static struct s_bi4i4i4i4u8_ b_s_bi4i4i4i4u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi4i4i4i4u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi4i4i4i4u8_* pret = DataTransfer::GetPointer<s_bi4i4i4i4u8_>(context, MaybeRet.ToLocalChecked());
    s_bi4i4i4i4u8_ ret = pret ? *pret : s_bi4i4i4i4u8_ {};
    return ret;
        
}

static struct s_bi8_ b_s_bi8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi8_* pret = DataTransfer::GetPointer<s_bi8_>(context, MaybeRet.ToLocalChecked());
    s_bi8_ ret = pret ? *pret : s_bi8_ {};
    return ret;
        
}

static struct s_bo_ b_s_bo_s(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bo_s");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bo_* pret = DataTransfer::GetPointer<s_bo_>(context, MaybeRet.ToLocalChecked());
    s_bo_ ret = pret ? *pret : s_bo_ {};
    return ret;
        
}

static struct s_br4_ b_s_br4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_br4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_br4_* pret = DataTransfer::GetPointer<s_br4_>(context, MaybeRet.ToLocalChecked());
    s_br4_ ret = pret ? *pret : s_br4_ {};
    return ret;
        
}

static struct s_br8_ b_s_br8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_br8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_br8_* pret = DataTransfer::GetPointer<s_br8_>(context, MaybeRet.ToLocalChecked());
    s_br8_ ret = pret ? *pret : s_br8_ {};
    return ret;
        
}

static struct s_i4i4i4i4u8_ b_s_i4i4i4i4u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_i4i4i4i4u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4u8_* pret = DataTransfer::GetPointer<s_i4i4i4i4u8_>(context, MaybeRet.ToLocalChecked());
    s_i4i4i4i4u8_ ret = pret ? *pret : s_i4i4i4i4u8_ {};
    return ret;
        
}

static struct s_ooor4r4_ b_s_ooor4r4_s_ooor4r4_(void* target, struct s_ooor4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_ooor4r4_s_ooor4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_ooor4r4_* pret = DataTransfer::GetPointer<s_ooor4r4_>(context, MaybeRet.ToLocalChecked());
    s_ooor4r4_ ret = pret ? *pret : s_ooor4r4_ {};
    return ret;
        
}

static struct s_ossi4i4i4i4o_ b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_(void* target, struct s_ossi4i4i4i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_ossi4i4i4i4o_* pret = DataTransfer::GetPointer<s_ossi4i4i4i4o_>(context, MaybeRet.ToLocalChecked());
    s_ossi4i4i4i4o_ ret = pret ? *pret : s_ossi4i4i4i4o_ {};
    return ret;
        
}

static struct s_pi4_ b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* target, void* p0, struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_pi4_* pret = DataTransfer::GetPointer<s_pi4_>(context, MaybeRet.ToLocalChecked());
    s_pi4_ ret = pret ? *pret : s_pi4_ {};
    return ret;
        
}

static struct s_r4r4_ b_s_r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4_* pret = DataTransfer::GetPointer<s_r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4_ ret = pret ? *pret : s_r4r4_ {};
    return ret;
        
}

static struct s_r4r4_ b_s_r4r4_s_r4r4_(void* target, struct s_r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4_s_r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4_* pret = DataTransfer::GetPointer<s_r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4_ ret = pret ? *pret : s_r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4_ b_s_r4r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4_ ret = pret ? *pret : s_r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4_ b_s_r4r4r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4r4r4_ b_s_r4r4r4r4r4r4_(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4r4r4_");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4r4r4_ {};
    return ret;
        
}

static struct s_u8_ b_s_u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_u8_* pret = DataTransfer::GetPointer<s_u8_>(context, MaybeRet.ToLocalChecked());
    s_u8_ ret = pret ? *pret : s_u8_ {};
    return ret;
        
}

static void* b_si4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_si4");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_so(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_so");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sob");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_soo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_soo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sos");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ss(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ss");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ss_oi4osi4u1u1u1u1_(void* target, struct s_oi4osi4u1u1u1u1_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ss_oi4osi4u1u1u1u1_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ssi4Ps(void* target, void* p0, int32_t p1, void** p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ssi4Ps");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static uint16_t b_u2os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u2os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint16_t ret = converter::Converter<uint16_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint32_t b_u4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint32_t ret = converter::Converter<uint32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint32_t b_u4u4pu4(void* target, uint32_t p0, void* p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_u4u4pu4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<uint32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint32_t ret = converter::Converter<uint32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint64_t b_u8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint64_t ret = converter::Converter<uint64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void b_v(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_v");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vO");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOb(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOoi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOoi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOsO(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOsO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOs_Oi4_(void* target, void* p0, struct s_Oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOs_Oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOs_Oi4_o(void* target, void* p0, struct s_Oi4_ p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOs_Oi4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_(void* target, struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vb(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vb");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbbi4(void* target, bool p0, bool p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vbbi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<bool>::toScript(context, p0),
        converter::Converter<bool>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbs(void* target, bool p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vbs");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<bool>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbso(void* target, bool p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vbso");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<bool>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4O(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4O");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4(void* target, int32_t p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4i4p(void* target, int32_t p0, int32_t p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4i4p");

    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4r4(void* target, int32_t p0, int32_t p1, float p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<float>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i8i8b(void* target, int32_t p0, int64_t p1, int64_t p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i8i8b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int64_t>::toScript(context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4o(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4popO(void* target, int32_t p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4popO");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4popo(void* target, int32_t p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4popo");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s_r4r4r4_s_r4r4r4r4_r4i4(void* target, int32_t p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, int32_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s_r4r4r4_s_r4r4r4r4_r4i4");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<float>::toScript(context, p3),
        converter::Converter<int32_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s_r4r4r4r4_(void* target, int32_t p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s_r4r4r4r4_");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8(void* target, int64_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int64_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8i8(void* target, int64_t p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8i8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8o(void* target, int64_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vo");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vob");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4i4(void* target, void* p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4oo(void* target, void* p0, int32_t p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi8i8i8i8i8i8i8(void* target, void* p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, int64_t p5, int64_t p6, int64_t p7, void* method) {
    // PLog(LogLevel::Log, "Running b_voi8i8i8i8i8i8i8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        converter::Converter<int64_t>::toScript(context, p3),
        converter::Converter<int64_t>::toScript(context, p4),
        converter::Converter<int64_t>::toScript(context, p5),
        converter::Converter<int64_t>::toScript(context, p6),
        converter::Converter<int64_t>::toScript(context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooi8(void* target, void* p0, void* p1, int64_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooi8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int64_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[9]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 9, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[10]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 10, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[11]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 11, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[12]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 12, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[13]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 13, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[14]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 14, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[15]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 15, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* p15, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);
    auto TIp15 = GetParameterType(method, 15);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[16]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14),
        CSRefToJsValue(isolate, context, p15)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 16, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voos(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voos");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor4(void* target, void* p0, float p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vor4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<float>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor4r4r4(void* target, void* p0, float p1, float p2, float p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vor4r4r4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<float>::toScript(context, p1),
        converter::Converter<float>::toScript(context, p2),
        converter::Converter<float>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor8(void* target, void* p0, double p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vor8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<double>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_Pvi4i4i4pi4i4oi4_(void* target, void* p0, struct s_Pvi4i4i4pi4i4oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4_(void* target, void* p0, struct s_i4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4_ob(void* target, void* p0, struct s_i4_ p1, void* p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4_ob");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4i4i4i4_b(void* target, void* p0, struct s_i4i4i4i4_ p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4i4i4i4_b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_oi4osi4u1u1u1u1_(void* target, void* p0, struct s_oi4osi4u1u1u1u1_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_oi4osi4u1u1u1u1_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4_(void* target, void* p0, struct s_r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4r4_(void* target, void* p0, struct s_r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4r4r4_(void* target, void* p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_sosi4i4i4i4i4_i4(void* target, void* p0, struct s_sosi4i4i4i4i4_ p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_sosi4i4i4i4i4_i4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vosb(void* target, void* p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vosb");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voss_i4i4i4i4_b(void* target, void* p0, void* p1, struct s_i4i4i4i4_ p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voss_i4i4i4i4_b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vou4(void* target, void* p0, uint32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vou4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vp");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi4Po(void* target, void* p0, int32_t p1, void** p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi4Po");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpppi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vpppi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpppi4i8(void* target, void* p0, void* p1, void* p2, int32_t p3, int64_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vpppi4i8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p3),
        converter::Converter<int64_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vps(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vps");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu4u4(void* target, void* p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu4u4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4(void* target, float p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<float>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4Ps_r4r4r4r4_Pr4Pr4(void* target, float p0, struct s_r4r4r4r4_* p1, float* p2, float* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4Ps_r4r4r4r4_Pr4Pr4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<float>::toScript(context, p0),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsVi4(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsVi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    auto arrayLength = GetArrayLength(p1);
    v8::Local<v8::Value> *Argv = (v8::Local<v8::Value> *)alloca(sizeof(v8::Local<v8::Value>) * (1 + arrayLength));
    memset(Argv, 0, sizeof(v8::Local<v8::Value>) * (1 + arrayLength));
    Argv[0] = CSAnyToJsValue(isolate, context, p0);
    RestArguments<int32_t>::UnPackPrimitive(context, p1, arrayLength, TIp1, Argv + 1);
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2 + arrayLength - 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_Oi4_(void* target, struct s_Oi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_Oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs__(void* target, struct s__ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs__");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_(void* target, struct s_i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_b(void* target, struct s_i4_ p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_b");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_i4(void* target, struct s_i4_ p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_i4i4(void* target, struct s_i4_ p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_i4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s(void* target, struct s_i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s_Pvi4i4i4pi4i4oi4_(void* target, struct s_i4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s_Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s_i4_(void* target, struct s_i4_ p0, struct s_i4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s_i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_(void* target, struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i8_(void* target, struct s_i4i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i8_o(void* target, struct s_i4i8_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i8_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4o_(void* target, struct s_i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4o_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4osu8i8_(void* target, struct s_i4osu8i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4osu8i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4r4r4i4_(void* target, struct s_i4r4r4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4r4r4i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4ss_(void* target, struct s_i4ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4u1u1_(void* target, struct s_i4u1u1_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4u1u1_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i8i8_(void* target, struct s_i8i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i8i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oo_(void* target, struct s_oo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oob_(void* target, struct s_oob_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oob_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oooObr4r4r4r4bb_(void* target, struct s_oooObr4r4r4r4bb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oooObr4r4r4r4bb_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ossi4i4i4i4o_(void* target, struct s_ossi4i4i4i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ossi4i4i4i4o_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pi4_(void* target, struct s_pi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pi4_o(void* target, struct s_pi4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pi4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ppi4i4_o(void* target, struct s_ppi4i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ppi4i4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pu4_(void* target, struct s_pu4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pu4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4oi4_(void* target, struct s_r4r4oi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4_(void* target, struct s_r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_(void* target, struct s_r4r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_i4(void* target, struct s_r4r4r4r4_ p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_i4bb(void* target, struct s_r4r4r4r4_ p0, int32_t p1, bool p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_i4bb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<bool>::toScript(context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_o(void* target, struct s_r4r4r4r4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_oo(void* target, struct s_r4r4r4r4_ p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_so_(void* target, struct s_so_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_so_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_soo_(void* target, struct s_soo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_soo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ss_(void* target, struct s_ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8_(void* target, struct s_u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8b_(void* target, struct s_u8b_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8b_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_(void* target, struct s_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsb(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsbs(void* target, void* p0, bool p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsbs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_(void* target, void* p0, bool p1, struct s_Pvi4i4i4pi4i4oi4i4i4i4_ p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsoo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsoo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsr4Vs(void* target, void* p0, float p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsr4Vs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    auto arrayLength = GetArrayLength(p2);
    v8::Local<v8::Value> *Argv = (v8::Local<v8::Value> *)alloca(sizeof(v8::Local<v8::Value>) * (2 + arrayLength));
    memset(Argv, 0, sizeof(v8::Local<v8::Value>) * (2 + arrayLength));
    Argv[0] = CSAnyToJsValue(isolate, context, p0);
    Argv[1] = converter::Converter<float>::toScript(context, p1);
    RestArguments<void*>::UnPackRefOrBoxedValueType(context, p2, arrayLength, TIp2, Argv + 2);
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3 + arrayLength - 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsr4Vs_r4r4r4_(void* target, void* p0, float p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsr4Vs_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    auto arrayLength = GetArrayLength(p2);
    v8::Local<v8::Value> *Argv = (v8::Local<v8::Value> *)alloca(sizeof(v8::Local<v8::Value>) * (2 + arrayLength));
    memset(Argv, 0, sizeof(v8::Local<v8::Value>) * (2 + arrayLength));
    Argv[0] = CSAnyToJsValue(isolate, context, p0);
    Argv[1] = converter::Converter<float>::toScript(context, p1);
    RestArguments<s_r4r4r4_>::UnPackValueType(context, p2, arrayLength, TIp2, Argv + 2);
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3 + arrayLength - 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vss_r4r4r4r4_(void* target, void* p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vss_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vssi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vssi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu1(void* target, uint8_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vu1");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<uint8_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu4u4Ps_ppi4i4p_(void* target, uint32_t p0, uint32_t p1, struct s_ppi4i4p_* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vu4u4Ps_ppi4i4p_");

    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<uint32_t>::toScript(context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu8o(void* target, uint64_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vu8o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<uint64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static BridgeFuncInfo g_bridgeFuncInfos[] = {
    
    {"O", (MethodPointer)b_O},
    {"OO", (MethodPointer)b_OO},
    {"OVO", (MethodPointer)b_OVO},
    {"Oi4popb", (MethodPointer)b_Oi4popb},
    {"Oo", (MethodPointer)b_Oo},
    {"Ooo", (MethodPointer)b_Ooo},
    {"Oooo", (MethodPointer)b_Oooo},
    {"Opi4", (MethodPointer)b_Opi4},
    {"Opi4O", (MethodPointer)b_Opi4O},
    {"Oppi4", (MethodPointer)b_Oppi4},
    {"Os_oooObr4r4r4r4bb_", (MethodPointer)b_Os_oooObr4r4r4r4bb_},
    {"Oso", (MethodPointer)b_Oso},
    {"b", (MethodPointer)b_b},
    {"bO", (MethodPointer)b_bO},
    {"bOooi4", (MethodPointer)b_bOooi4},
    {"bPs", (MethodPointer)b_bPs},
    {"bPs_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_", (MethodPointer)b_bPs_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_},
    {"bb", (MethodPointer)b_bb},
    {"bi4", (MethodPointer)b_bi4},
    {"bi4i4i4po", (MethodPointer)b_bi4i4i4po},
    {"bo", (MethodPointer)b_bo},
    {"boO", (MethodPointer)b_boO},
    {"boPi4", (MethodPointer)b_boPi4},
    {"boPsPs", (MethodPointer)b_boPsPs},
    {"boi4", (MethodPointer)b_boi4},
    {"boi4O", (MethodPointer)b_boi4O},
    {"boo", (MethodPointer)b_boo},
    {"booi4", (MethodPointer)b_booi4},
    {"boooi4", (MethodPointer)b_boooi4},
    {"booso", (MethodPointer)b_booso},
    {"boso", (MethodPointer)b_boso},
    {"bososo", (MethodPointer)b_bososo},
    {"bosso", (MethodPointer)b_bosso},
    {"bosss", (MethodPointer)b_bosss},
    {"bossss", (MethodPointer)b_bossss},
    {"bp", (MethodPointer)b_bp},
    {"bpi4", (MethodPointer)b_bpi4},
    {"bs", (MethodPointer)b_bs},
    {"bsO", (MethodPointer)b_bsO},
    {"bs_i4ss_", (MethodPointer)b_bs_i4ss_},
    {"bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_", (MethodPointer)b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_},
    {"bs_u8_", (MethodPointer)b_bs_u8_},
    {"bs_u8u8u4u4u4u4i4oo_oo", (MethodPointer)b_bs_u8u8u4u4u4u4i4oo_oo},
    {"bsbi4s", (MethodPointer)b_bsbi4s},
    {"bsooi4", (MethodPointer)b_bsooi4},
    {"bu1o", (MethodPointer)b_bu1o},
    {"csi4c", (MethodPointer)b_csi4c},
    {"i2os", (MethodPointer)b_i2os},
    {"i4", (MethodPointer)b_i4},
    {"i4i4i4", (MethodPointer)b_i4i4i4},
    {"i4i4i4ob", (MethodPointer)b_i4i4i4ob},
    {"i4i4sb", (MethodPointer)b_i4i4sb},
    {"i4o", (MethodPointer)b_i4o},
    {"i4ob", (MethodPointer)b_i4ob},
    {"i4oi4o", (MethodPointer)b_i4oi4o},
    {"i4oo", (MethodPointer)b_i4oo},
    {"i4os", (MethodPointer)b_i4os},
    {"i4os_r4r4r4_s_r4r4_ob", (MethodPointer)b_i4os_r4r4r4_s_r4r4_ob},
    {"i4p", (MethodPointer)b_i4p},
    {"i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_", (MethodPointer)b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_},
    {"i8o", (MethodPointer)b_i8o},
    {"i8os", (MethodPointer)b_i8os},
    {"o", (MethodPointer)b_o},
    {"oO", (MethodPointer)b_oO},
    {"oOo", (MethodPointer)b_oOo},
    {"oOs", (MethodPointer)b_oOs},
    {"oOsooo", (MethodPointer)b_oOsooo},
    {"oPs", (MethodPointer)b_oPs},
    {"oPs_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_", (MethodPointer)b_oPs_Pu1i4i4i4i4u4u4i8i8i8i8i8i8i8i8i8i8i8u4i4bbbpi4pi4pi4ci4pi4pi4pi4_},
    {"oi4", (MethodPointer)b_oi4},
    {"oi4o", (MethodPointer)b_oi4o},
    {"oi4oo", (MethodPointer)b_oi4oo},
    {"oi4popb", (MethodPointer)b_oi4popb},
    {"oi4s", (MethodPointer)b_oi4s},
    {"oi8oo", (MethodPointer)b_oi8oo},
    {"oo", (MethodPointer)b_oo},
    {"ooO", (MethodPointer)b_ooO},
    {"ooi4", (MethodPointer)b_ooi4},
    {"ooi4s_r4r4_ooPi4", (MethodPointer)b_ooi4s_r4r4_ooPi4},
    {"ooo", (MethodPointer)b_ooo},
    {"oooO", (MethodPointer)b_oooO},
    {"oooi4", (MethodPointer)b_oooi4},
    {"oooi8o", (MethodPointer)b_oooi8o},
    {"oooo", (MethodPointer)b_oooo},
    {"ooooO", (MethodPointer)b_ooooO},
    {"ooooo", (MethodPointer)b_ooooo},
    {"oooooO", (MethodPointer)b_oooooO},
    {"oooooo", (MethodPointer)b_oooooo},
    {"ooooooo", (MethodPointer)b_ooooooo},
    {"oooooooo", (MethodPointer)b_oooooooo},
    {"ooooooooo", (MethodPointer)b_ooooooooo},
    {"oooooooooo", (MethodPointer)b_oooooooooo},
    {"ooooooooooo", (MethodPointer)b_ooooooooooo},
    {"oooooooooooo", (MethodPointer)b_oooooooooooo},
    {"ooooooooooooo", (MethodPointer)b_ooooooooooooo},
    {"oooooooooooooo", (MethodPointer)b_oooooooooooooo},
    {"ooooooooooooooo", (MethodPointer)b_ooooooooooooooo},
    {"oooooooooooooooo", (MethodPointer)b_oooooooooooooooo},
    {"ooooooooooooooooo", (MethodPointer)b_ooooooooooooooooo},
    {"ooor4", (MethodPointer)b_ooor4},
    {"ooos_r4r4_i4", (MethodPointer)b_ooos_r4r4_i4},
    {"oos", (MethodPointer)b_oos},
    {"oos_ooo_", (MethodPointer)b_oos_ooo_},
    {"oosb", (MethodPointer)b_oosb},
    {"ooso", (MethodPointer)b_ooso},
    {"oosu8", (MethodPointer)b_oosu8},
    {"oou4u4", (MethodPointer)b_oou4u4},
    {"opi4", (MethodPointer)b_opi4},
    {"os", (MethodPointer)b_os},
    {"osi4o", (MethodPointer)b_osi4o},
    {"osooo", (MethodPointer)b_osooo},
    {"oss", (MethodPointer)b_oss},
    {"pp", (MethodPointer)b_pp},
    {"pppi4i8", (MethodPointer)b_pppi4i8},
    {"r4", (MethodPointer)b_r4},
    {"r4i4", (MethodPointer)b_r4i4},
    {"r4i4i4r4", (MethodPointer)b_r4i4i4r4},
    {"r4o", (MethodPointer)b_r4o},
    {"r4os", (MethodPointer)b_r4os},
    {"r4r4", (MethodPointer)b_r4r4},
    {"r4r4Ps_r4r4r4r4_", (MethodPointer)b_r4r4Ps_r4r4r4r4_},
    {"r4s_r4r4r4_", (MethodPointer)b_r4s_r4r4r4_},
    {"r8", (MethodPointer)b_r8},
    {"r8o", (MethodPointer)b_r8o},
    {"r8os", (MethodPointer)b_r8os},
    {"s", (MethodPointer)b_s},
    {"sO", (MethodPointer)b_sO},
    {"s__", (MethodPointer)b_s__},
    {"s_bi4_o", (MethodPointer)b_s_bi4_o},
    {"s_bi4i4i4i4u8_o", (MethodPointer)b_s_bi4i4i4i4u8_o},
    {"s_bi8_o", (MethodPointer)b_s_bi8_o},
    {"s_bo_s", (MethodPointer)b_s_bo_s},
    {"s_br4_o", (MethodPointer)b_s_br4_o},
    {"s_br8_o", (MethodPointer)b_s_br8_o},
    {"s_i4i4i4i4u8_o", (MethodPointer)b_s_i4i4i4i4u8_o},
    {"s_ooor4r4_s_ooor4r4_", (MethodPointer)b_s_ooor4r4_s_ooor4r4_},
    {"s_ossi4i4i4i4o_s_ossi4i4i4i4o_", (MethodPointer)b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_},
    {"s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", (MethodPointer)b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4_o", (MethodPointer)b_s_r4r4_o},
    {"s_r4r4_s_r4r4_", (MethodPointer)b_s_r4r4_s_r4r4_},
    {"s_r4r4r4_o", (MethodPointer)b_s_r4r4r4_o},
    {"s_r4r4r4r4_o", (MethodPointer)b_s_r4r4r4r4_o},
    {"s_r4r4r4r4r4r4_", (MethodPointer)b_s_r4r4r4r4r4r4_},
    {"s_u8_o", (MethodPointer)b_s_u8_o},
    {"si4", (MethodPointer)b_si4},
    {"so", (MethodPointer)b_so},
    {"sob", (MethodPointer)b_sob},
    {"soo", (MethodPointer)b_soo},
    {"sos", (MethodPointer)b_sos},
    {"ss", (MethodPointer)b_ss},
    {"ss_oi4osi4u1u1u1u1_", (MethodPointer)b_ss_oi4osi4u1u1u1u1_},
    {"ssi4Ps", (MethodPointer)b_ssi4Ps},
    {"u2os", (MethodPointer)b_u2os},
    {"u4os", (MethodPointer)b_u4os},
    {"u4u4pu4", (MethodPointer)b_u4u4pu4},
    {"u8os", (MethodPointer)b_u8os},
    {"v", (MethodPointer)b_v},
    {"vO", (MethodPointer)b_vO},
    {"vOO", (MethodPointer)b_vOO},
    {"vOb", (MethodPointer)b_vOb},
    {"vOo", (MethodPointer)b_vOo},
    {"vOoi4", (MethodPointer)b_vOoi4},
    {"vOsO", (MethodPointer)b_vOsO},
    {"vOs_Oi4_", (MethodPointer)b_vOs_Oi4_},
    {"vOs_Oi4_o", (MethodPointer)b_vOs_Oi4_o},
    {"vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_},
    {"vb", (MethodPointer)b_vb},
    {"vbbi4", (MethodPointer)b_vbbi4},
    {"vbs", (MethodPointer)b_vbs},
    {"vbso", (MethodPointer)b_vbso},
    {"vi4", (MethodPointer)b_vi4},
    {"vi4O", (MethodPointer)b_vi4O},
    {"vi4i4", (MethodPointer)b_vi4i4},
    {"vi4i4i4p", (MethodPointer)b_vi4i4i4p},
    {"vi4i4r4", (MethodPointer)b_vi4i4r4},
    {"vi4i8i8b", (MethodPointer)b_vi4i8i8b},
    {"vi4o", (MethodPointer)b_vi4o},
    {"vi4popO", (MethodPointer)b_vi4popO},
    {"vi4popo", (MethodPointer)b_vi4popo},
    {"vi4s_r4r4r4_s_r4r4r4r4_r4i4", (MethodPointer)b_vi4s_r4r4r4_s_r4r4r4r4_r4i4},
    {"vi4s_r4r4r4r4_", (MethodPointer)b_vi4s_r4r4r4r4_},
    {"vi8", (MethodPointer)b_vi8},
    {"vi8i8", (MethodPointer)b_vi8i8},
    {"vi8o", (MethodPointer)b_vi8o},
    {"vo", (MethodPointer)b_vo},
    {"voO", (MethodPointer)b_voO},
    {"vob", (MethodPointer)b_vob},
    {"voi4", (MethodPointer)b_voi4},
    {"voi4i4", (MethodPointer)b_voi4i4},
    {"voi4o", (MethodPointer)b_voi4o},
    {"voi4oo", (MethodPointer)b_voi4oo},
    {"voi8", (MethodPointer)b_voi8},
    {"voi8i8i8i8i8i8i8", (MethodPointer)b_voi8i8i8i8i8i8i8},
    {"voo", (MethodPointer)b_voo},
    {"vooi4", (MethodPointer)b_vooi4},
    {"vooi8", (MethodPointer)b_vooi8},
    {"vooo", (MethodPointer)b_vooo},
    {"voooo", (MethodPointer)b_voooo},
    {"vooooo", (MethodPointer)b_vooooo},
    {"voooooo", (MethodPointer)b_voooooo},
    {"vooooooo", (MethodPointer)b_vooooooo},
    {"voooooooo", (MethodPointer)b_voooooooo},
    {"vooooooooo", (MethodPointer)b_vooooooooo},
    {"voooooooooo", (MethodPointer)b_voooooooooo},
    {"vooooooooooo", (MethodPointer)b_vooooooooooo},
    {"voooooooooooo", (MethodPointer)b_voooooooooooo},
    {"vooooooooooooo", (MethodPointer)b_vooooooooooooo},
    {"voooooooooooooo", (MethodPointer)b_voooooooooooooo},
    {"vooooooooooooooo", (MethodPointer)b_vooooooooooooooo},
    {"voooooooooooooooo", (MethodPointer)b_voooooooooooooooo},
    {"voos", (MethodPointer)b_voos},
    {"vor4", (MethodPointer)b_vor4},
    {"vor4r4r4", (MethodPointer)b_vor4r4r4},
    {"vor8", (MethodPointer)b_vor8},
    {"vos", (MethodPointer)b_vos},
    {"vos_Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vos_Pvi4i4i4pi4i4oi4_},
    {"vos_i4_", (MethodPointer)b_vos_i4_},
    {"vos_i4_ob", (MethodPointer)b_vos_i4_ob},
    {"vos_i4i4i4i4_b", (MethodPointer)b_vos_i4i4i4i4_b},
    {"vos_oi4osi4u1u1u1u1_", (MethodPointer)b_vos_oi4osi4u1u1u1u1_},
    {"vos_r4r4_", (MethodPointer)b_vos_r4r4_},
    {"vos_r4r4r4_", (MethodPointer)b_vos_r4r4r4_},
    {"vos_r4r4r4r4_", (MethodPointer)b_vos_r4r4r4r4_},
    {"vos_sosi4i4i4i4i4_i4", (MethodPointer)b_vos_sosi4i4i4i4i4_i4},
    {"vosb", (MethodPointer)b_vosb},
    {"voss_i4i4i4i4_b", (MethodPointer)b_voss_i4i4i4i4_b},
    {"vou4", (MethodPointer)b_vou4},
    {"vp", (MethodPointer)b_vp},
    {"vpO", (MethodPointer)b_vpO},
    {"vpi4Po", (MethodPointer)b_vpi4Po},
    {"vpi4o", (MethodPointer)b_vpi4o},
    {"vpi8", (MethodPointer)b_vpi8},
    {"vpo", (MethodPointer)b_vpo},
    {"vpppi4", (MethodPointer)b_vpppi4},
    {"vpppi4i8", (MethodPointer)b_vpppi4i8},
    {"vps", (MethodPointer)b_vps},
    {"vpu4u4", (MethodPointer)b_vpu4u4},
    {"vr4", (MethodPointer)b_vr4},
    {"vr4Ps_r4r4r4r4_Pr4Pr4", (MethodPointer)b_vr4Ps_r4r4r4r4_Pr4Pr4},
    {"vs", (MethodPointer)b_vs},
    {"vsVi4", (MethodPointer)b_vsVi4},
    {"vs_Oi4_", (MethodPointer)b_vs_Oi4_},
    {"vs__", (MethodPointer)b_vs__},
    {"vs_i4_", (MethodPointer)b_vs_i4_},
    {"vs_i4_b", (MethodPointer)b_vs_i4_b},
    {"vs_i4_i4", (MethodPointer)b_vs_i4_i4},
    {"vs_i4_i4i4", (MethodPointer)b_vs_i4_i4i4},
    {"vs_i4_s", (MethodPointer)b_vs_i4_s},
    {"vs_i4_s_Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vs_i4_s_Pvi4i4i4pi4i4oi4_},
    {"vs_i4_s_i4_", (MethodPointer)b_vs_i4_s_i4_},
    {"vs_i4i4_", (MethodPointer)b_vs_i4i4_},
    {"vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_", (MethodPointer)b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_},
    {"vs_i4i8_", (MethodPointer)b_vs_i4i8_},
    {"vs_i4i8_o", (MethodPointer)b_vs_i4i8_o},
    {"vs_i4o_", (MethodPointer)b_vs_i4o_},
    {"vs_i4osu8i8_", (MethodPointer)b_vs_i4osu8i8_},
    {"vs_i4r4r4i4_", (MethodPointer)b_vs_i4r4r4i4_},
    {"vs_i4ss_", (MethodPointer)b_vs_i4ss_},
    {"vs_i4u1u1_", (MethodPointer)b_vs_i4u1u1_},
    {"vs_i8i8_", (MethodPointer)b_vs_i8i8_},
    {"vs_oo_", (MethodPointer)b_vs_oo_},
    {"vs_oob_", (MethodPointer)b_vs_oob_},
    {"vs_oooObr4r4r4r4bb_", (MethodPointer)b_vs_oooObr4r4r4r4bb_},
    {"vs_ossi4i4i4i4o_", (MethodPointer)b_vs_ossi4i4i4i4o_},
    {"vs_pi4_", (MethodPointer)b_vs_pi4_},
    {"vs_pi4_o", (MethodPointer)b_vs_pi4_o},
    {"vs_ppi4i4_o", (MethodPointer)b_vs_ppi4i4_o},
    {"vs_pu4_", (MethodPointer)b_vs_pu4_},
    {"vs_r4r4oi4_", (MethodPointer)b_vs_r4r4oi4_},
    {"vs_r4r4r4_", (MethodPointer)b_vs_r4r4r4_},
    {"vs_r4r4r4r4_", (MethodPointer)b_vs_r4r4r4r4_},
    {"vs_r4r4r4r4_i4", (MethodPointer)b_vs_r4r4r4r4_i4},
    {"vs_r4r4r4r4_i4bb", (MethodPointer)b_vs_r4r4r4r4_i4bb},
    {"vs_r4r4r4r4_o", (MethodPointer)b_vs_r4r4r4r4_o},
    {"vs_r4r4r4r4_oo", (MethodPointer)b_vs_r4r4r4r4_oo},
    {"vs_so_", (MethodPointer)b_vs_so_},
    {"vs_soo_", (MethodPointer)b_vs_soo_},
    {"vs_ss_", (MethodPointer)b_vs_ss_},
    {"vs_u8_", (MethodPointer)b_vs_u8_},
    {"vs_u8b_", (MethodPointer)b_vs_u8b_},
    {"vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_", (MethodPointer)b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_},
    {"vsb", (MethodPointer)b_vsb},
    {"vsbs", (MethodPointer)b_vsbs},
    {"vsbs_Pvi4i4i4pi4i4oi4i4i4i4_", (MethodPointer)b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_},
    {"vsi4", (MethodPointer)b_vsi4},
    {"vso", (MethodPointer)b_vso},
    {"vsoo", (MethodPointer)b_vsoo},
    {"vsr4Vs", (MethodPointer)b_vsr4Vs},
    {"vsr4Vs_r4r4r4_", (MethodPointer)b_vsr4Vs_r4r4r4_},
    {"vss", (MethodPointer)b_vss},
    {"vss_r4r4r4r4_", (MethodPointer)b_vss_r4r4r4r4_},
    {"vssi4", (MethodPointer)b_vssi4},
    {"vsso", (MethodPointer)b_vsso},
    {"vu1", (MethodPointer)b_vu1},
    {"vu4u4Ps_ppi4i4p_", (MethodPointer)b_vu4u4Ps_ppi4i4p_},
    {"vu8o", (MethodPointer)b_vu8o},
    {nullptr, nullptr}
};


static void ifg_i4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_i4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    int32_t ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_i4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_i4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    int32_t p = converter::Converter<int32_t>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_r4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_r4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    float ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_r4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_r4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    float p = converter::Converter<float>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    void* ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_s(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_s");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal s
    v8::String::Utf8Value tp(isolate, info[0]);
    void* p = CStringToCSharpString(*tp);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_s_r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p = pp ? *pp : s_r4r4r4_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_u8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_u8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_u8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_s_u8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_u8_* pp = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p = pp ? *pp : s_u8_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_ti4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ti4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    int32_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_ti4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_ti4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    int32_t p = converter::Converter<int32_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_to(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_to");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
}

static void ifs_to(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_to");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tr4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tr4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    float ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tr4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_tr4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    float p = converter::Converter<float>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    //PLog(LogLevel::Log, "Running ifs_ts_r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p = pp ? *pp : s_r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static FieldWrapFuncInfo g_fieldWrapFuncInfos[] = {
    
    {"i4", ifg_i4, ifs_i4},
    {"r4", ifg_r4, ifs_r4},
    {"s", ifg_s, ifs_s},
    {"s_r4r4r4_", ifg_s_r4r4r4_, ifs_s_r4r4r4_},
    {"s_u8_", ifg_s_u8_, ifs_s_u8_},
    {"ti4", ifg_ti4, ifs_ti4},
    {"to", ifg_to, ifs_to},
    {"tr4", ifg_tr4, ifs_tr4},
    {"ts_r4r4r4_", ifg_ts_r4r4r4_, ifs_ts_r4r4r4_},
    {nullptr, nullptr, nullptr}    
};

